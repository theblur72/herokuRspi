"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultCamera = void 0;
const default_1 = require("../watcher/default");
const default_2 = require("../executor/default");
const cla_mapper_1 = require("@dlukanin/cla-mapper");
class DefaultCamera {
    constructor(options = {}, _watcher = new default_1.DefaultWatcher(), _executor = new default_2.DefaultRaspistillExecutor()) {
        this._watcher = _watcher;
        this._executor = _executor;
        this._options = {};
        this._optionsMap = {
            verticalFlip: '-vf',
            horizontalFlip: '-hf',
            noPreview: '-n',
            encoding: '-e',
            width: '-w',
            height: '-h',
            time: '-t',
            iso: '-ISO',
            shutterspeed: '-ss',
            contrast: '-co',
            timelapse: '-tl',
            brightness: '-br',
            saturation: '-sa',
            awb: '-awb',
            awbg: '-awbg',
            quality: '-q',
            thumb: '-th',
            rotation: '-rot',
            output: '-o',
            exposure: '-ex',
            flicker: '-fli',
            imageEffect: '-ifx',
            drc: '-drc'
        };
        this._defaultOptions = {
            noFileSave: false,
            verticalFlip: false,
            horizontalFlip: false,
            noPreview: true,
            outputDir: 'photos',
            encoding: 'jpg'
        };
        this._optionsParser = new cla_mapper_1.ClaMapper(this._optionsMap);
        this.setOptions(Object.assign({}, this._defaultOptions, options));
    }
    setOptions(options) {
        Object.assign(this._options, options);
    }
    getOptions() {
        return this._options;
    }
    getOption(key) {
        return this._options[key];
    }
    async timelapse(...args) {
        let fileName;
        let intervalMs;
        let execTimeMs;
        let cb;
        if (typeof args[0] === 'string') {
            fileName = args[0];
            intervalMs = args[1];
            execTimeMs = args[2];
            cb = args[3];
        }
        else {
            intervalMs = args[0];
            execTimeMs = args[1];
            cb = args[2];
        }
        if (this._options.noFileSave) {
            return await this._executor.spawnAndGetImages(this._processOptions({
                time: execTimeMs,
                timelapse: intervalMs,
                fileName
            }), cb);
        }
        let cameraFileName = this._options.fileName || Date.now().toString() + '%04d';
        let cameraEncoding = this._options.encoding;
        if (fileName && fileName.length) {
            const processedFileName = fileName.split('.');
            if (processedFileName.length > 1) {
                cameraFileName = processedFileName[0];
                cameraEncoding = processedFileName[1];
            }
            else {
                cameraFileName = fileName;
            }
        }
        await Promise.all([
            this._executor.exec(this._processOptions({
                fileName: cameraFileName,
                encoding: cameraEncoding,
                time: execTimeMs,
                timelapse: intervalMs
            })),
            this._watcher.watchAndGetFiles(this._options.outputDir, execTimeMs, cb)
        ]);
    }
    async takePhoto(fileName) {
        if (this._options.noFileSave === true) {
            return await this._executor.spawnAndGetImage(this._processOptions());
        }
        let cameraFileName = this._options.fileName || Date.now().toString();
        let cameraEncoding = this._options.encoding;
        if (fileName && fileName.length) {
            const processedFileName = fileName.split('.');
            if (processedFileName.length > 1) {
                cameraFileName = processedFileName[0];
                cameraEncoding = processedFileName[1];
            }
            else {
                cameraFileName = fileName;
            }
        }
        const result = await Promise.all([
            this._executor.exec(this._processOptions({
                fileName: cameraFileName,
                encoding: cameraEncoding
            })),
            this._watcher.watchAndGetFile(this._options.outputDir + '/' + (cameraFileName + '.' + cameraEncoding))
        ]);
        if (result instanceof Array) {
            return result[1];
        }
        return result;
    }
    stop() {
        this._watcher.closeWatcher();
        this._executor.killProcess();
    }
    _processOptions(newOptions = {}) {
        const options = Object.assign({}, this._options, newOptions);
        options.output = options.noFileSave === true ? '-' :
            (options.outputDir + '/' + options.fileName + '.' + options.encoding);
        return this._optionsParser.getCommandLineArgs(options);
    }
}
exports.DefaultCamera = DefaultCamera;
//# sourceMappingURL=default.js.map