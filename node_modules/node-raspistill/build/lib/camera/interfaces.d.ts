/// <reference types="node" />
export declare type TCameraFileEncoding = 'jpg' | 'bmp' | 'gif' | 'png';
export interface ICameraOptions {
    noFileSave?: boolean;
    verticalFlip?: boolean;
    horizontalFlip?: boolean;
    rotation?: number;
    noPreview?: boolean;
    outputDir?: string;
    fileName?: string;
    encoding?: TCameraFileEncoding;
    width?: number;
    height?: number;
    time?: number;
    iso?: number;
    shutterspeed?: number;
    contrast?: number;
    brightness?: number;
    saturation?: number;
    awb?: string;
    awbg?: string;
    quality?: number;
    thumb?: string;
    exposure?: 'auto' | 'night' | 'nightpreview' | 'backlight' | 'spotlight' | 'sports' | 'snow' | 'beach' | 'verylong' | 'fixedfps' | 'antishake' | 'fireworks';
    flicker?: 'off' | 'auto' | '50hz' | '60hz';
    imageEffect?: 'none' | 'negative' | 'solarise' | 'posterise' | 'whiteboard' | 'blackboard' | 'sketch' | 'denoise' | 'emboss' | 'oilpaint' | 'hatch' | 'gpen' | 'pastel' | 'watercolour' | 'film' | 'blur' | 'saturation';
    drc?: 'off' | 'low' | 'med' | 'high';
}
export interface IInnerExecCameraOptions extends ICameraOptions {
    timelapse?: number;
    output?: string;
}
export interface ICamera {
    takePhoto(fileName?: string): Promise<Buffer>;
    timelapse(fileName: string, intervalMs: number, execTimeMs: number, cb: (image: Buffer) => any): Promise<void>;
    timelapse(intervalMs: number, execTimeMs: number, cb: (image: Buffer) => any): Promise<void>;
    stop(): void;
    setOptions(options: ICameraOptions): void;
    getOptions(): ICameraOptions;
    getOption(key: string): any;
}
