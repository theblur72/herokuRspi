"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultWatcher = void 0;
const fs = require("fs");
const path = require("path");
const interrupt_1 = require("../error/interrupt");
const __1 = require("../..");
class DefaultWatcher {
    constructor(options) {
        this._options = {};
        this._imageInProgressSymbol = '~';
        this._forceCloseEvent = 'forceClose';
        this._defaultOptions = {
            expireTime: 20000
        };
        this._messages = {
            EVENT_RENAME: 'rename',
            EVENT_CHANGE: 'change',
            ENOENT: 'ENOENT',
            EEXISTS: 'EEXIST'
        };
        this.setOptions(Object.assign({}, this._defaultOptions, options));
    }
    setOptions(options) {
        Object.assign(this._options, options);
    }
    getOption(key) {
        return this._options[key];
    }
    getOptions() {
        return this._options;
    }
    async watchAndGetFile(filePath, options) {
        const dirName = path.dirname(filePath);
        const fileName = path.basename(filePath);
        this._makeDir(dirName);
        return await new Promise((resolve, reject) => {
            let timeout;
            const watcher = fs.watch(dirName, (eventType, changedFileName) => {
                if ((eventType === this._messages.EVENT_RENAME || eventType === this._messages.EVENT_CHANGE) &&
                    fileName === changedFileName) {
                    clearTimeout(timeout);
                    watcher.close();
                    fs.readFile(filePath, (err, data) => {
                        if (err) {
                            if (err.code === this._messages.ENOENT) {
                                resolve(null);
                            }
                            reject(err);
                        }
                        resolve(data);
                    });
                }
            });
            timeout = setTimeout(() => {
                watcher.close();
                reject(new __1.RaspistillDefaultError(__1.RaspistillDefaultError.CODE_NO_PHOTO));
            }, this.getOption('expireTime'));
            this.addForceCloseHandler(watcher, timeout, reject);
            this._watcher = watcher;
        });
    }
    async watchAndGetFiles(dirPath, watchTimeMs, cb) {
        const dirName = path.basename(dirPath);
        this._makeDir(dirName);
        return await new Promise((resolve, reject) => {
            const watcher = fs.watch(dirName, (eventType, changedFileName) => {
                if (changedFileName[changedFileName.length - 1] === this._imageInProgressSymbol) {
                    return;
                }
                if ((eventType === this._messages.EVENT_RENAME)) {
                    fs.readFile(dirName + '/' + changedFileName, (err, data) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            cb(data);
                        }
                    });
                }
            });
            this.addForceCloseHandler(watcher, setTimeout(() => {
                watcher.close();
                resolve();
            }, watchTimeMs), reject);
            this._watcher = watcher;
        });
    }
    closeWatcher() {
        if (this._watcher) {
            this._watcher.emit(this._forceCloseEvent);
        }
    }
    _makeDir(dirName) {
        try {
            fs.mkdirSync(dirName, { recursive: true });
        }
        catch (err) {
            if (err.code !== this._messages.EEXISTS) {
                throw err;
            }
        }
    }
    addForceCloseHandler(watcher, timer, reject) {
        watcher.on(this._forceCloseEvent, () => {
            clearTimeout(timer);
            watcher.close();
            reject(new interrupt_1.RaspistillInterruptError());
        });
    }
}
exports.DefaultWatcher = DefaultWatcher;
//# sourceMappingURL=default.js.map