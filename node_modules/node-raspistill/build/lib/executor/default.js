"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultRaspistillExecutor = void 0;
const child_process_1 = require("child_process");
const imageType = require("image-type");
const interrupt_1 = require("../error/interrupt");
const raspistill_1 = require("../error/raspistill");
class DefaultRaspistillExecutor {
    constructor() {
        this._forceCloseSignal = 'SIGTERM';
        this._command = 'raspistill';
        this._maxBuffer = 400 * 1024;
    }
    async exec(args) {
        return new Promise((resolve, reject) => {
            this._childProcess = child_process_1.execFile(this._command, args, {
                maxBuffer: this._maxBuffer,
                encoding: 'buffer'
            }, (error, stdout, stderr) => {
                if (error) {
                    reject(error);
                }
                resolve(stdout);
            });
        });
    }
    async spawnAndGetImage(args) {
        return await new Promise((resolve, reject) => {
            let photoBuffer = Buffer.alloc(0);
            let errorBuffer = Buffer.alloc(0);
            let error;
            const childProcess = child_process_1.spawn(this._command, args);
            childProcess.on('error', (processError) => {
                error = processError;
            });
            childProcess.on('exit', (code, signal) => {
                if (signal === this._forceCloseSignal) {
                    reject(new interrupt_1.RaspistillInterruptError());
                    return;
                }
                if (error) {
                    reject(error);
                    return;
                }
                if (errorBuffer.toString().length) {
                    reject(new raspistill_1.RaspistillDefaultError(raspistill_1.RaspistillDefaultError.CODE_SPAWN_PROC_ERROR, errorBuffer.toString()));
                    return;
                }
                resolve(photoBuffer);
            });
            childProcess.stdout.on('data', (data) => {
                photoBuffer = Buffer.concat([photoBuffer, data]);
            });
            childProcess.stderr.on('data', (data) => {
                errorBuffer = Buffer.concat([errorBuffer, data]);
            });
            this._childProcess = childProcess;
        });
    }
    async spawnAndGetImages(args, cb) {
        await new Promise((resolve, reject) => {
            let photoBuffer = Buffer.alloc(0);
            let error;
            const childProcess = child_process_1.spawn(this._command, args);
            childProcess.on('error', (processError) => {
                error = processError;
            });
            childProcess.on('exit', (code, signal) => {
                if (signal === this._forceCloseSignal) {
                    reject(new interrupt_1.RaspistillInterruptError());
                    return;
                }
                if (error) {
                    childProcess.kill();
                    reject(error);
                    return;
                }
                cb(photoBuffer);
                resolve();
            });
            childProcess.stdout.on('data', (data) => {
                if (imageType(data) && photoBuffer.length) {
                    cb(photoBuffer);
                    photoBuffer = data;
                    return;
                }
                photoBuffer = Buffer.concat([photoBuffer, data]);
            });
            this._childProcess = childProcess;
        });
    }
    killProcess() {
        if (this._childProcess && this._childProcess.kill) {
            this._childProcess.kill(this._forceCloseSignal);
        }
    }
}
exports.DefaultRaspistillExecutor = DefaultRaspistillExecutor;
//# sourceMappingURL=default.js.map